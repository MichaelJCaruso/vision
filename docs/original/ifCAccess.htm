<!DOCTYPE html>
<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>Sample C++ Access to Vision</title>
</head>
<body bgcolor="#FFFFFF">

<h2>
Sample C++ Access to Vision</h2>
| <a href="FHome.htm">Home</a> | <a href="vifaces.htm">Interfaces</a> |
<a href="ifDownload.htm#ifCAccess">Download
Scripts</a> |
<hr>
<h3>
Topics Covered:</h3>

<ul type=square>
<li>
<a href="#Introduction">Introduction</a></li>

<li>
<a href="#Operation">Operation</a></li>

<li>
<a href="#Compilation">Compilation</a></li>

<li>
<a href="#Reference">Reference</a></li>

<li>
<a href="#VArrayBase">class VArrayBase</a></li>

<li>
<a href="#VArray">class VArray</a></li>

<li>
<a href="#VConnection">class VConnection</a></li>

<li>
<a href="#VConnectionUse">class VConnectionUse</a></li>

<li>
<a href="#VDatum">class VDatum</a></li>

<li>
<a href="#VExtractWS">class VExtractWS</a></li>

<li>
<a href="#VSockets">class VSockets</a></li>

<li>
<a href="#VStringBase">class VStringBase</a></li>

<li>
<a href="#VString">class VString</a></li>
</ul>

<hr><a NAME="Introduction"></a>
<h3>
Introduction</h3>
The Vision C++ interface kit consists of a set of C++ classes that you
use to provide structured access to Vision data. The classes in this kit
provide you with array and character based access to Vision.
<p>The Vision C++ interface kit is supplied in <a href="ifDownload.htm#ifCAccess">source
code form.</a> You are encouraged to modify that source code to suit your
needs. The kit has been tested using default compilation options under
the following combinations of operating systems and compilers:
<br>&nbsp;
<center><table BORDER >
<tr>
<th>Operating System</th>

<th><b>Compiler Version</b></th>
</tr>

<tr>
<td>HP-UX/10.01</td>

<td>HP C++ Version A.10.01</td>
</tr>

<tr>
<td>IBM AIX/4.2</td>

<td>IBM C Set ++ For AIX 3.1.4.3</td>
</tr>

<tr>
<td>Sun Solaris/5.5</td>

<td>Sun Sparcompiler C++ 4.1</td>
</tr>

<tr>
<td>Microsoft Windows/NT 3.51</td>

<td>Microsoft Visual C++ 4.2&nbsp;</td>
</tr>
</table></center>

<p>The functionality of the Vision C++ interface kit is also available in COM form
using the <a href="ifVAccess.htm">VAccess COM objects</a>.
<br><a NAME="Operation"></a>
<h3>
Operation</h3>
The Vision C++ interface kit provides array and character oriented, socket
based access to Vision. When you use the kit, you primarily work with instances
of the six classes summarized in the following table:
<table BORDER >
<tr>
<td><b>Class Name</b></td>

<td><b>Class Description</b></td>
</tr>

<tr>
<td VALIGN=TOP>VSockets</td>

<td>A class that hides a number of operating system dependencies in the
use of sockets, including the need to explicitly initialize the socket
library in Windows environments. Your application must create exactly one
instance of this class in order to function. That instance should be created
when your application starts and destroyed when your application terminates.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>VConnection&nbsp;</td>

<td>A class that provides connections to Vision. It can launch new Vision
sessions using the remote execution daemon or connect to existing Vision
servers running at known port addresses. For both kinds of connections,
this class's 'submit' member function allows you to receive the output
generated by any Vision expression you specify. This class also provides
member functions to process Vision include files, execute a Vision expression
without returning any output and obtain the value of an item for an entity
in your Vision data base. To use Vision, you need to create one instance
of this class although you can create more if your application needs to
talk to more than one Vision session at a time.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>VExtractWS&nbsp;</td>

<td>This class encapsulates array based retrieval of Vision data using
Vision's ExtractWS interface. Your application can create as many instances
of this class as it needs.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>VString&nbsp;</td>

<td>This class implements variable length character strings. An instance
of this class is used to receive the output returned by VConnection's 'submit'
member function. You can also use this class as a tool that does the book-keeping
of string management.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>VDatum&nbsp;</td>

<td>This class implements a variant type capable of holding numeric, string,
or NA data. When you retrieve data using the VExtractWS interface to Vision,
your data is returned as an array of VDatum objects.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>VDatumArray</td>

<td>This class implements a variably sized array of VDatum objects. An
instance of this class is used to receive data returned by VExtractWS based
data requests. You can create and use as many instances of this class as
your application needs.</td>
</tr>
</table>

<p>The remainder of this section illustrates how these classes are used
to access Vision. That illustration begins with the include files needed
to access the definitions of these classes.
<p>Every application source code file you write that uses the classes defined
in the Vision C++ interface kit needs to include the header files that
define those classes. The class descriptions given in the reference section
of this document supply the names of those files. Every file that includes
one of those class definition files should include <i>VStdLib.h</i> before
it includes any of the interface kit's class definition files. The example
illustrated in this section needs the following files:
<b><pre>&nbsp;&nbsp;&nbsp; #include "VStdLib.h"

&nbsp;&nbsp;&nbsp; #include "VSockets.h"
&nbsp;&nbsp;&nbsp; #include "VConnection.h"
&nbsp;&nbsp;&nbsp; #include "VExtractWS.h"</pre></b>
Note that because <i>VStdLib.h</i> already includes a number of standard
C++ header files, you may not need to include them again yourself, although
there is generally no harm done if you do.
<p>The example illustrating this section does most of its work in a classic
UNIX style main program although the techniques are applicable to GUI based
Windows style programs as well.
<p>As noted in the introduction to this section, every application that
uses the Vision C++ interface kit needs to create a single instance of
class <i>VSockets</i> when it starts. The first few lines of this main
program create that instance and test to make certain that it was properly
initialized:
<b><pre>&nbsp;&nbsp;&nbsp; int main (int argc, char* argv[])
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VSockets SocketSubsystem (VTrue);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!SocketSubsystem.initialized ())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Socket Initialization Failed!!\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; //&nbsp; Do something useful here...

&nbsp;&nbsp;&nbsp; }</pre></b>
The <i>VSockets</i> class encapsulates the operating system dependencies
associated with using sockets. One of those dependencies is the need to
make an explicit initialization call when using the Windows based implementation
of the socket libraries. The <i>VTrue</i> passed to the VSockets constructor
asks the constructor to make that call. It also ultimately asks the destructor
for this <i>VSockets</i> object to make the corresponding de-initialization
call. If your application is already making those calls, either directly
or because of some other class library it is using, you should pass <i>VFalse</i>
to the <i>VSockets</i> constructor and NOT perform the SocketSubsystem.initialized()
test shown above.
<p>Once your instance of <i>VSockets</i> has been created, you can use
it to create one or more Vision sessions or connect to one or more Vision
servers. Most applications, including the one illustrated here, only need
one connection to do their work, but you can create as many connections
as you need. The following statement creates a
<i>VConnection</i> object:
<b><pre>&nbsp;&nbsp;&nbsp; VConnection myConnection (SocketSubsystem);</pre></b>
Creating a <i>VConnection</i> object does not actually connect you to a
Vision session. To do that, you need to call either the <b>rexec</b> or
<b>connect</b><i>VConnection</i>
member function.
<p>The <b>rexec</b> member function uses the remote execution daemon to
start a private Vision session for your use:
<b><pre>&nbsp;&nbsp;&nbsp; char iMessageBuffer[256];
&nbsp;&nbsp;&nbsp; if (!myConnection.rexec (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iMessageBuffer, sizeof (iMessageBuffer),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (argc, argv),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (argc, argv),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Password&nbsp;&nbsp;&nbsp; (argc, argv),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Command&nbsp;&nbsp;&nbsp;&nbsp; (argc, argv)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Connection Attempt Failed!!\nReason: %s",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iMessageBuffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp;&nbsp; }</pre></b>
This function accepts six arguments, the first two of which supply a buffer
which will be filled with an error message if your session could not be
started. The next three arguments specify the host, user name, and password
used to create your session. The final argument is optional -- it supplies
the command string used to start your batchvision session. If you do not
supply this argument, the interface kit will run <i>/vision/bin/batchvision</i>
with no arguments. The <i>Host</i>, <i>User</i>, <i>Password</i>, and <i>Command</i>
functions called here are not part of the interface kit -- they are simply
syntactically valid placeholders for the argument values you must supply.
It is your responsibility to supply those values in whatever way is appropriate.
<p>If the <b>rexec</b> member function succeeds, it returns a non-zero
value. If it fails it returns 0 and places a string in the message buffer
you supplied indicating the reason for its failure.
<p>The <b>connect</b> member function is the other way to establish a connection
to a Vision session:
<b><pre>&nbsp;&nbsp;&nbsp; if (!myConnection.connect (Host (argc, argv), 8001))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf (stderr, "Connection Attempt Failed!!\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;
&nbsp;&nbsp;&nbsp; }</pre></b>
This function accepts two arguments -- the name of a host and the number
of a port. It expects to find a Vision server listening for connections
at the specified port on the specified host. In the case illustrated here,
the host is obtained from the command line and the port is hardwired to
port 8001. There is nothing magic about this number -- you or your Vision
administrator decide what it will be when the service is created.
<p>Like the <b>rexec</b> member function, the <b>connect</b> member function
returns a non-zero value when it succeeds and zero when it fails.
<p>You can call either or both of these member functions as often as you
need or care to for a given connection. Each call disconnects the current
Vision session if one was established and creates or connects to a new
session based on the argument values you supply.
<p>Once you have connected your <i>VConnection</i> object to a Vision session,
you can use it to run Vision expressions and retrieve data from Vision.
The 'submit' VConnection member function allows you to run an arbitrary
Vision expression and collect the output it generates. For example:
<b><pre>&nbsp;&nbsp;&nbsp; VString iBalanceSheet;
&nbsp;&nbsp;&nbsp; if (myConnection.submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iBalanceSheet,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Named Company IBM balanceSheet"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Balance Sheet:\n%s\n", (char const*)iBalanceSheet
&nbsp;&nbsp;&nbsp; );</pre></b>
requests a balance sheet from Vision and writes it to standard output.
<p>The <b>submit</b> member function expects two required arguments --
an instance of a <i>VString</i> object which will receive the output generated
by your Vision request and a null-terminated character string containing
the text of that request. The <b>submit</b> member function returns a non-zero
value when it succeeds and zero when it fails.
<p>As noted earlier, the <i>VString</i> class is one of three helper classes
provided in the Vision C++ interface kit used to receive results from Vision.
As illustrated here in the call to <b>printf</b>, VString objects can be
used anywhere a 'const' C++ string can be used. In most cases, the compiler
makes the necessary conversion automatically; however, in this case, the
compiler does not know what type of value to pass to
<b>printf</b> so an
explicit cast is required.
<p>In addition to its required arguments, the <b>submit</b> member function
accepts four optional arguments -- two that specify the global date and
currency applicable to your request and two that are helpful in collecting
very large and very small quantities of output.
<p>The first and second optional arguments to <b>submit</b> (its fourth
and fifth actual arguments) specify the date as of which to run your request
and the default currency to which to convert monetary values when processing
that request. Both arguments are specified as strings and can be null (i.e.,
(char const*)0) to select your system's default value for the parameter.
For example:
<b><pre>&nbsp;&nbsp;&nbsp; VString iBalanceSheet;
&nbsp;&nbsp;&nbsp; if (myConnection.submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iBalanceSheet,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Named Company IBM balanceSheet",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (char const*)0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CHF"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Balance Sheet:\n%s\n", (char const*)iBalanceSheet
&nbsp;&nbsp;&nbsp; );</pre></b>
requests IBM's balance sheet reported in Swiss Francs while:
<b><pre>&nbsp;&nbsp;&nbsp; VString iBalanceSheet;
&nbsp;&nbsp;&nbsp; if (myConnection.submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iBalanceSheet,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Named Company IBM balanceSheet",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "93"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Balance Sheet:\n%s\n", (char const*)iBalanceSheet
&nbsp;&nbsp;&nbsp; );</pre></b>
requests IBM's balance sheet as of 1993, and:
<b><pre>&nbsp;&nbsp;&nbsp; VString iBalanceSheet;
&nbsp;&nbsp;&nbsp; if (myConnection.submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iBalanceSheet,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Named Company IBM balanceSheet",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "93",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "CHF"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Balance Sheet:\n%s\n", (char const*)iBalanceSheet
&nbsp;&nbsp;&nbsp; );</pre></b>
requests IBM's balance sheet as of 1993 reported in Swiss Francs.
<p>The fifth and sixth arguments to <b>submit</b> specify, respectively,
how much buffer space to initially allocate for the reply to your request
and by how much to grow that space when the current allocation proves insufficient.
Both arguments default to 4096 bytes. If you know in advance that you are
expecting a very large or a very small amount of output, you can pass more
appropriate values for these optional parameters.
<p>The <b>submit</b> member function is not the only way to interact with
Vision using a <i>VConnection</i> object. The <b>execute</b> member function
is an alternative to <b>submit</b> if you do not care about the output
generated by your request. The <b>execute</b> member function takes one
required argument -- a null terminated character string containing the
Vision expression you want executed -- and two optional arguments -- the
global date and currency applicable to that expression. Like the
<b>submit</b>
member function, <b>execute</b> returns a non-zero value if it was able
to run your Vision expression and zero if it could not.
<p>The <i>VConnection</i> class also provides <b>include</b> member functions
to process Vision include files. These functions read and execute a file
of Vision code resident on the system where your Vision session is running.
Both return a non-zero value if they were able to ask Vision to process
the file and zero if they could not.
<p>Finally, the <i>VConnection</i> class provides the <b>getValue</b> member
functions. These member functions access the value of an item for an entity
in your Vision data base. For example:
<b><pre>&nbsp;&nbsp;&nbsp; double iReal;
&nbsp;&nbsp;&nbsp; if (myConnection.getValue (iReal, "Company", "IBM", "sales"))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Display (iReal);
&nbsp;&nbsp;&nbsp; else printf ("Could not get IBM's sales!\n");</pre></b>
returns the value of IBM's sales as of the current date, expressed in the
default currency for your data base. The <b>getValue</b> function is overloaded
based on the C++ data type you want returned. The overload used here returns
the item's value as a real number. Other versions of this member function
return their value as an integer, a VString, and a VDatum -- a Vision C++
interface kit data type discussed in greater detail below. All of the <b>getValue</b>
members return a non-zero value if they were able to submit your request
to Vision and convert its result to the result type required by the overloaded
member you called.
<p>The <b>getValue</b> member functions also accept two optional arguments
that specify the date and currency to use when retrieving the item. For
example:
<b><pre>&nbsp;&nbsp;&nbsp; if (myConnection.getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iReal, "Company", "IBM", "sales", "93"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) Display (iReal);
&nbsp;&nbsp;&nbsp; else printf ("Could not get IBM's sales!\n");</pre></b>
accesses IBM's sales as of 1993 while:
<b><pre>&nbsp;&nbsp;&nbsp; if (myConnection.getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iReal, "Company", "IBM", "sales", 0, "CHF"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) Display (iReal);
&nbsp;&nbsp;&nbsp; else printf ("Could not get IBM's sales!\n");</pre></b>
accesses IBM's most recent sales expressed in Swiss Francs and:
<b><pre>&nbsp;&nbsp;&nbsp; if (myConnection.getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iReal, "Company", "IBM", "sales", "93", "CHF"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ) Display (iReal);
&nbsp;&nbsp;&nbsp; else printf ("Could not get IBM's sales!\n");</pre></b>
accesses IBM's sales as of 1993 expressed in Swiss Francs.
<p>The <i>VConnection</i> class provides a relatively unstructured interface
to
Vision. The <i>VDatumArray</i> and <i>VExtractWS</i> classes provide a
structured interface. In particular, the <i>VExtractWS</i> class provides
you with access to the <b>Interface ExtractWS</b> Vision ToolKit for retrieving
array structured data from Vision. The following Vision C++ interface kit
code creates a VExtractWS object initialized to request a 4 row by 3 column
entity by item array of data:
<b><pre>&nbsp;&nbsp;&nbsp; VExtractWS iExtractWS1 (&amp;myConnection);
&nbsp;&nbsp;&nbsp; iExtractWS1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setOrientationToEI ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setDelimiterTo ("##")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityTypeTo ("Security")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("GM")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("IBM")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("HWP")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("XON")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("name"&nbsp;&nbsp;&nbsp; , VDatumKind_String)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("price"&nbsp;&nbsp; , VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("price@95", VDatumKind_Real)
&nbsp;&nbsp;&nbsp; ;</pre></b>
The preceeding code fragment specifies the data you want to retrieve; the
following interface kit code actually gets it:
<b><pre>&nbsp;&nbsp;&nbsp; VDatumArray iDatumArray1;

&nbsp;&nbsp;&nbsp; if (iExtractWS1.run (iDatumArray1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayArray (iDatumArray1);</pre></b>
The <b>DisplayArray</b> function is not part of the interface kit -- it
is an example of a routine you would write to do something with the data
you retrieved. It might look like this:
<b><pre>&nbsp;&nbsp;&nbsp; void DisplayArray (VDatumArray const&amp; myDataArray)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t rowCount = myDataArray.elementCount(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t colCount = myDataArray.elementCount(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (unsigned int row = 0; row &lt; rowCount; row++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (unsigned int col = 0; col &lt; colCount; col++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; iElement = myDataArray.element (row, col);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (iElement.kind ())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_NA:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is NA\n", row, col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_Integer:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The Integer %d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (int)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_Real:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The Real Number %g\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (double)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_String:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The String &lt;%s>\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (char const*)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Has An Unrecognized Type\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }</pre></b>
The <b>run</b> member function returns a non-zero value when it succeeds
and zero when it fails. When the call illustrated above succeeds, iDatumArray1
contains four rows -- one for each Security -- and three columns -- one
for each item -- specified in the calls that created iExtractWS1.
<p>The items added to this extract workspace were added with data types.
When you explicitly specify a data type with an item, the interface kit
will store or convert the returned values for that item to the type you
specify. If the item's value cannot be converted to that type, it will
be stored as NA. In this case, the values in column 0 (the first column)
will all be strings while the values in column 1 and 2 (the second and
third columns) will be stored as real numbers (i.e., C++ type double) or
NA. The item type is an optional argument to the <b>addItem</b> and <b>setItemTo</b><i>VExtractWS</i>
member functions -- if it is omitted or specified as VDatumKind_NA, the
Vision C++ interface kit will attempt to convert the item's value to a
number if possible, returning the value as a string if and only if it isn't
explicitly recognized as a Vision NA or cannot be converted to a numeric
value.
<p>You can modify the settings associated with a <i>VExtractWS</i> object
and re-run it. The following example adds an entity and an item to the
extract workspace object created above, changes its orientation to item
by entity, and re-runs it.
<b><pre>&nbsp;&nbsp;&nbsp; iExtractWS1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setOrientationToIE ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("ACD")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("company compustat sales")
&nbsp;&nbsp;&nbsp; ;
&nbsp;&nbsp;&nbsp; if (iExtractWS1.run (iDatumArray1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayArray (iDatumArray1);
&nbsp;&nbsp;&nbsp; printf ("\n");</pre></b>
When you re-use an extract workspace object, only your changes are transmitted
to Vision. You can request that all of the current settings in the workspace
be re-transmitted when you re-run the workspace. You do that by passing
a non-zero value as the value of the <b>run</b> member function's first
optional parameter:
<b><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iExtractWS1.run (iDatumArray1, VTrue))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayArray (iDatumArray1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("\n");</pre></b>
You can create as many <i>VExtractWS</i> and <i>VDatumArray</i> objects
as your application needs. Each VExtractWS corresponds to a distinct ExtractWS
object in your Vision session that does not interfere with any other workspace
object. When you destroy one of your <i>VExtractWS</i> objects, the corresponding
remote object is also destroyed.
<p>The following code creates and initializes a second workspace and uses
it to fill a second data array:
<b><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS iExtractWS2 (&amp;myConnection);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iExtractWS2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setOrientationToET ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setColumnLabelsOn ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setRowLabelsOn ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityTypeTo ("Security")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setItemTo ("price", VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityListTo ("GM, IBM, HWP, XON")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9601")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9512")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9511")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9510")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9509")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9508")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9507")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9506")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9505")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9504")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9503")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9502")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addDate ("9501")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatumArray iDatumArray2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iExtractWS2.run (iDatumArray2))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayArray (iDatumArray2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("\n");</pre></b>
Note that this example also illustrates one of two alternate methods for
specifying an entity list. In this case, the entity list is specified as
a comma separated list of values. You can also use Vision's Interface ExtractWS
ability to generate the list dynamically as the following example illustrates:
<b><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS iExtractWS3 (&amp;myConnection);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iExtractWS3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setOrientationToEI ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setColumnLabelsOn ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setScalarLabelOn ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityTypeTo ("Security")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityTo ("IBM")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityListExpressionTo ("holdings")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("account name"&nbsp;&nbsp;&nbsp; , VDatumKind_String)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("shares"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("totalCost"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("totalMarketValue", VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatumArray iDatumArray3 (2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iExtractWS3.run (iDatumArray3))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DisplayArray (iDatumArray3);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf ("\n");</pre></b>

<pre>
<hr WIDTH="100%"><a NAME="Compilation"></a></pre>

<h3>
Compilation</h3>
The Vision C++ interface kit is supplied in source code form. In general,
you should add these files to the project or makefile you are using to
develop your application, compile the '.c' versions of these files with
your C++ compiler, and link the resultant object code with your application.
For the operating system and compiler combinations tested, no special compilation
options are required; however, you may need to change the file name suffix
of the '.c' files to the suffix your compiler associates with C++ code.
If you compile these files using non-standard compiler option values, you
may need to make adjustments to the source code they contain to make them
work with your option settings.
<p>In addition to possibly renaming the '.c' files, you may need to add
one or more libraries to the list of run-time libraries with which you
link your application. In all cases, these libraries provide support for
the socket calls made by the classes included in the interface kit.
<p>The following table summarizes these operating system and compiler dependencies:
<center><table BORDER >
<tr>
<th>Operating System</th>

<th>C++ Compiler</th>

<th>C++ Source Code Suffix</th>

<th>Additional Libraries&nbsp;</th>
</tr>

<tr>
<td>HP-UX/10.01</td>

<td>CC</td>

<td>.c</td>

<td></td>
</tr>

<tr>
<td>IBM AIX/4.2</td>

<td>xlC</td>

<td>.C (.c if -+ option used)</td>
</tr>

<tr>
<td>Sun Solaris/5.5</td>

<td>CC</td>

<td>.c</td>

<td>socket nsl</td>
</tr>

<tr>
<td>Windows/NT 3.51</td>

<td>.cpp</td>

<td>wsock32.lib&nbsp;</td>
</tr>
</table></center>

<p>
<hr WIDTH="100%">
<br><a NAME="Reference"></a>
<h3>
Reference</h3>

<a NAME="VArrayBase"></a>
<h4>
class VArrayBase</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>VArray&lt;T&gt;
<p><b>Definition:</b>
<br>#include "VArray.h"
<h4>
Overview</h4>
The <i>VArrayBase</i> class provides an abstract class foundation for multi-dimensional
arrays of arbitrary size and shape.
<p>This class is a pure abstract class that cannot be instantiated directly.
Its purpose in life is to provide the implementations of element type independent
operations to the <i>VArray</i> class template. Primarily, those operations
deal with setting and querying the size and shape of an array.
<p>You can access a multi-dimensional array either multi-dimensionally
or as a vector which linearizes the array in "row-major" order. The member
functions defined in this class help you to construct and decode a linearized
view of an array.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Counts and Sizes

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; size_t dimensionCount () const;

&nbsp;&nbsp;&nbsp;&nbsp; size_t elementCount (unsigned int xDimension) const;
&nbsp;&nbsp;&nbsp;&nbsp; size_t elementSize (unsigned int xDimension) const;

&nbsp;&nbsp;&nbsp;&nbsp; size_t arraySize (unsigned int xDimension = 0) const;

</pre><h5>Remarks:</h5></b>
<br>The <b>dimensionCount</b> member function returns the number of dimensions
in an array. The other functions in this category accept the index of a
dimension and return information about the number of elements in or along
that dimension. The <b>elementCount</b> member function returns the number
of elements along an axis of the array; the <b>elementSize</b> and <b>arraySize</b>
member functions return the total number of elements at or below a dimension.
Without an argument or with an argument value of 0, the arraySize member
function returns the total number of elements in the array. The following
table summarizes the values returned for a 4 x 3 x 7 array:
<b><pre>&nbsp;&nbsp;&nbsp; xDim&nbsp;&nbsp; elementCount(xDim)&nbsp;&nbsp; elementSize(xDim)&nbsp;&nbsp; arraySize(xDim)
&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 84
&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21
&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7</pre></b>
You are most likely to use <b>dimensionCount()</b>, <b>elementCount(xDim)</b>,
and <b>arraySize ()</b> in your applications.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Element Offset

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int elementOffset (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int xSubscript0, ...
&nbsp;&nbsp;&nbsp;&nbsp; ) const;

&nbsp;&nbsp;&nbsp;&nbsp; unsigned int elementOffset (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list pSubscriptVector, unsigned int xSubscript0
&nbsp;&nbsp;&nbsp;&nbsp; ) const;

&nbsp;&nbsp;&nbsp;&nbsp; unsigned int elementOffset (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int const* pSubscriptVector
&nbsp;&nbsp;&nbsp;&nbsp; ) const;

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category convert a collection of array
subscripts into a linearized array offset. They offer three argument passing
mechanisms -- variable length argument lists, &lt;stdarg.h> argument pointers,
and subscript arrays. In all cases, it is your responsibility to pass as
many subscripts as there are dimensions in your array or your application
will fail and almost certainly crash.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Array Resizing

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; void reshape (VArrayBase const&amp; iOtherArray);

&nbsp;&nbsp;&nbsp;&nbsp; void reshape (size_t sDimensionVector, ...);
&nbsp;&nbsp;&nbsp;&nbsp; void reshape (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t sDimensionVector, va_list pDimensionVector
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; void reshape (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t sDimensionVector, size_t const *pDimensionVector
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; void clear ();

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category change the shape and size of
an array. You can change the size and shape of an array to match the size
and shape of an array you pass as an argument to the reshape function or
you can explicitly specify the new shape and size. If you explicitly specify
the shape and size, you can do so using a variable length argument list
(i.e., new dimension count followed by a size for each dimension), a dimension
count and &lt;stdarg.h>based argument list, or a dimension count and size
array. In all cases, you are responsible for specifying a size for each
dimension or your application will almost certainly crash and will certainly
behave in unexpected and incorrect ways. When you reshape an array, as
many of the elements as possible in the original linearized array are preserved.
For example if you change a 7 x 3 array into a 2 x 4 array, the first 8
elements of the original array are preserved. In addition to the general
ability to reshape an array, you can also discard all of the elements in
an array. The clear() member function preserves the dimensionality of an
array but discards all of the elements in the array by changing the size
of the first dimension of the array to 0.
<p>
<hr WIDTH="100%"><a NAME="VArray"></a>
<h4>
template &lt;class T&gt; class VArray</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>VArrayBase
<p><b>Subclasses:</b>
<br>&lt;none>
<p><b>Definition:</b>
<br>#include "VArray.h"
<p><b>Instantiations:</b>
<br>typedef VArray&lt;VDatum> VDatumArray (in "VDatum.h")
<br>typedef VArray&lt;VString> VStringArray (in "VString.h")
<h4>
Overview</h4>
The <i>VArray</i> class template implements multi-dimensional arrays of
elements of almost arbitrary type. Derived from <i>VArrayBase</i>, from
which it inherits support for arrays of arbitrary size and dimensionality,
this class template adds the element type dependent operations of array
construction and subscripted element access.
<p>Any type that provides a default (i.e., argument-less) constructor and
that implements the =, ==, and != operators can be used to instantiate
this class template. Two publicly named instantiations are provided in
the Vision C++ interface kit -- <i>VDatumArray</i> and <i>VStringArray</i>.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VArray (VArray&lt;T&gt; const&amp; iOther);
&nbsp;&nbsp;&nbsp;&nbsp; VArray (size_t sDimensionVector = 1);

&nbsp;&nbsp;&nbsp;&nbsp; virtual ~VArray ();

</pre><h5>Remarks:</h5></b>
<br>The <i>VArray</i> constructors and destructors create new arrays. Two
constructors are provided -- a copy constructor and an empty array constructor.
The empty array constructor also functions as a default constructor which
creates an empty, one-dimensional array (i.e., a vector).
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Comparison

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (VArray&lt;T&gt; const &amp;iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (VArray&lt;T&gt; const &amp;iOther) const;

</pre><h5>Remarks:</h5></b>
<br>These member functions compare two arrays. Two arrays are considered
== if their shapes are the same (they have the same number of dimensions
with the same number of elements in each dimension) and all of their elements
are ==.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Element Access

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; E&amp; element (unsigned int xSubscript0, ...) const;
&nbsp;&nbsp;&nbsp;&nbsp; E&amp; element (unsigned int const* pSubscriptVector) const;

&nbsp;&nbsp;&nbsp;&nbsp; E&amp; operator[] (unsigned int xElement) const;

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category access an array's elements. Two
forms of element subscripting are supported -- multi-dimensional using
the 'element' member functions and linear using the [] operator. When using
either of the 'element' member functions, you are expected to supply a
subscript value for each dimension in the array -- either in the form of
an explicit parameter list or an array of subscripts. When using the []
operator, you are expected to supply a value between 0 and the total number
of elements in the array - 1. All of the following forms are equivalent:
<b><pre>&nbsp;&nbsp;&nbsp; myArray.element (0, 1);

&nbsp;&nbsp;&nbsp; myArray[elementOffset (0, 1)];

&nbsp;&nbsp;&nbsp; unsigned int mySubscripts[2];
&nbsp;&nbsp;&nbsp; mySubscripts[0] = 0;
&nbsp;&nbsp;&nbsp; mySubscripts[1] = 1;
&nbsp;&nbsp;&nbsp; myArray.element (mySubscripts);</pre></b>
All three member functions return a reference to the selected element.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Update

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VArray&lt;T&gt;&amp; operator= (VArray&lt;T&gt; const&amp; iOther);

&nbsp;&nbsp;&nbsp;&nbsp; VArray&lt;T&gt; operator&lt;&lt; (E const&amp; iElement);

&nbsp;&nbsp;&nbsp;&nbsp; E&amp; newElement ();

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category modify an existing array. operator=
is the standard C++ assignment operator. It reshapes the destination array
to match the shape of its argument and performs an element by element copy
of its argument. Both operator&lt;&lt; and newElement add one or more elements
to the end of an array. For one dimensional arrays, these routines are
self explanatory -- they add a new element to the end of the array. That
behavior is the degenerate case of the multi-dimensional case. For multi-dimensional
arrays, these routines increase the size of the first dimension by 1 and
either update (operator&lt;&lt;) or return a reference to (newElement)
the first element of the added sub-array.
<h4>

<hr WIDTH="100%"><a NAME="VConnection"></a></h4>

<h4>
class VConnection</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>&lt;none>
<p><b>Definition:</b>
<br>#include "VConnection.h"
<h4>
Overview</h4>
The <i>VConnection</i> class implements connections to Vision. You need
to create and initialize at least one <i>VConnection</i> object in order
to access Vision. You can have multiple connection objects, each talking
to a different Vision session, if you need them.
<p><i>VConnection</i> objects support two strategies for accessing Vision.
Their <b>rexec</b> member function uses the <b>rexec</b> service to start
a Vision session while their 'connect' member function contacts an existing
Vision server listening on a known port.
<p>Both the <b>rexec</b> and <b>connect</b> member functions can be called
multiple times. If an established connection exists when one of these member
functions is called, it will be disconnected and replaced by the connection
requested by the call, if possible.
<p>However connected, all connection objects allow you to execute Vision
expressions, process Vision include files, and obtain the value of an item
for an entity in your Vision data base. The routines to do these things
are described below and illustrated in the usage section of this document.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VConnection (VSockets&amp; iSocketManager);

&nbsp;&nbsp;&nbsp;&nbsp; virtual ~VConnection ();

</pre><h5>Remarks:</h5></b>
<br>Every <i>VConnection</i> object works in conjunction with a single
object of type <i>VSockets</i> which abstracts away the operating system
dependencies of the socket library. That <i>VSockets</i> object must be
passed to the <i>VConnection</i> constructor and must not be destroyed
so long as any <i>VConnection</i> object can use it. The usage section
of this document describes one technique for satisfying this requirement.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Remote Execution

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int rexec (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pErrorMessageBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sErrorMessageBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pHostName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pUserName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pPassword,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pCommand&nbsp; = "/vision/bin/batchvision"
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>The <b>rexec</b> member function uses the rexec protocol to start a
Vision session on the specified host for the specified user. This function
returns a non-zero value if the session was started successfully. If the
session could not be started, this function returns zero and places a description
of the start-up error, if one is available, in the error message buffer.
<p>Connections established using this member function support the full
remote execution protocol. In particular, they return error messages using
a separate channel and can be interrupted using the signal member function
described below.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Connection

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int connect (char const *pHostName, u_short xHostPort);

</pre><h5>Remarks:</h5></b>
<br>The <b>connect</b> member function establishes a connection to an existing
Vision server listening on a known port which you or your Vision administrator
selected when you created the service.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Disconnection

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; void disconnect ();

</pre><h5>Remarks:</h5></b>
<br>The <b>disconnect</b> member function disconnects from the Vision session
to which this <i>VConnection</i> object is currently connected. This member
function is called by the <b>rexec</b> and <b>connect</b> member functions
and the destructor for this class.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Request Execution

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VString&amp;&nbsp;&nbsp;&nbsp; iReply,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pRequest,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sReplyBufferInitialAllocation&nbsp;&nbsp; = 4096,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sReplyBufferAllocationIncrement = 4096,
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; int execute (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pRequest,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; int include (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pIncludeFileName
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; int include (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pIncludeFileName, VString&amp; iIncludeReply
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>The <b>submit</b> member function sends a request to Vision for execution.
If the request was successfully sent and its output was successfully received,
this routine returns a non-zero value, otherwise, this routine returns
zero. Successful requests replace the content of the <i>iReply VString</i>
object with the output generated by the request.
<p>The <b>submit</b> member function accepts four optional arguments two
that specify the date and currency globally applicable to your request
and two that tune the behavior of this routine when receiving very large
or very small amounts of output.
<p>The first and second optional arguments to <b>submit</b> specify the
default date and currency to use when running your request. Both arguments
are specified as strings and can be passed as null (i.e., (char const*)0)
to select your system's default for the parameter.
<p>This routine allocates a temporary buffer which it uses to collect a
request's output. That buffer is grown as necessary. The third and fourth
optional arguments to <b>submit</b> determine the initial size of that
buffer as well as the amount by which it grows when it is full. If you
anticipate a very large or very small amount of output for a given request,
you can pass your own values for these arguments to make the collection
of your output more efficient.
<p>The <b>execute</b> member function is an alternative way to submit a
Vision request for execution when you do not care about the output it returns.
The <b>execute</b> member function accepts the same request submission
parameters as submit -- a required request string and optional date and
currency strings -- and returns a non-zero value when it succeeds and a
zero when it fails.
<p>The <b>include</b> member functions allow you to execute a file of Vision
code. Both functions accept the path name of a file and ask your Vision
session to read and execute that file. The path name must specify the name
of a file accessible to the Vision session to which this <i>VConnection</i>
is speaking. This member is overloaded -- the two parameter form of this
member function allows you to inspect the output generated by your <i>include</i>
file while the one parameter form quietly discards that output. Both forms
return a non-zero value if they were able to submit the include request
to Vision and zero if they could not.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Value Retrieval

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp; int getValue (
&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp;&nbsp;&nbsp;&nbsp;&nbsp; iResult,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntityType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pItem,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp; int getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VString&amp;&nbsp;&nbsp;&nbsp; iResult,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntityType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pItem,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp; int getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double&amp;&nbsp;&nbsp;&nbsp;&nbsp; iResult,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntityType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pItem,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int getValue (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iResult,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntityType,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pEntity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pItem,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>The <b>getValue</b> member functions access the value of an item for
an entity in your Vision data base. The <b>getValue</b> member is overloaded
to permit you to retrieve the item's value as one of several different
C++ data types. In particular, there are overloaded versions of this member
that can return a <i>VDatum</i>, a <i>VString</i>, a double, or an integer.
<p>Aside from a reference to an object into which it will return your item's
value, each <b>getValue</b> member expects values for three required parameters
-- an entity type, an entity code, and an item name. In addition, each
accepts two optional parameters -- a string specifying the date as of which
the item's value is desired and a string specifying the currency to use
in processing and returning monetary values. Either or both of these optional
arguments can be null (i.e., (char const*)0) to request the default value
for that argument.
<p>All <b>getValue</b> members return a non-zero value if they were able
to submit your request to Vision and convert the value obtained to the
return type associated with the overloaded member you invoked. They all
return zero if they could not do both of these things.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Errors and Signals

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int signal (char xSignal = 2);

</pre><h5>Remarks:</h5></b>
<br>Vision sessions started using the <b>rexec</b> member function can
be interrupted using this member function. The single optional argument
to this routine is the index of the signal to be sent to the remote Vision
session. By default, this routine sends the same signal usually sent interactively
by control-C.
<p>This routine returns a non-zero value if the signal was sent; otherwise
it returns zero. This routine has no effect on sessions accessed using
the <b>connect</b> member function.
<p>Because the <b>submit</b>, <b>execute</b>, <b>include</b>, and <b>getValue</b>
member functions operate synchronously (i.e., they do not return until
they have received a reply from Vision), you must create a separate thread
to call this member function from your program.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Query

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int isConnected () const;
&nbsp;&nbsp;&nbsp;&nbsp; int isntConnected () const;

&nbsp;&nbsp;&nbsp;&nbsp; SOCKET dataSocket () const;
&nbsp;&nbsp;&nbsp;&nbsp; SOCKET controlSocket () const;

</pre><h5>Remarks:</h5></b>
<br>The routines in this category return status and socket information
about a connection. <b>isConnected</b> (<b>isntConnected</b>) determines
if a <i>VConnection</i> object is (isn't) currently connected to a Vision
session. <b>dataSocket</b> returns the socket handle used to pass requests
and receive replies. It is valid for connections established by both the
<b>connect</b>
and <b>rexec</b> member functions. Finally, <b>controlSocket</b> returns
the socket handle used to send signals and receive error messages for connections
established using the <b>rexec</b> member function of this class.
<h4>

<hr WIDTH="100%"><a NAME="VConnectionUse"></a></h4>

<h4>
class VConnectionUse</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>VExtractWS
<p><b>Definition:</b>
<br>#include "VConnectionUse.h"
<h4>
Overview</h4>
The <i>VConnectionUse</i> class is an abstract class that models the use
of a <i>VConnection object</i>. It is designed to be used as the base class
for other classes that provide structured access to Vision. The
<i>VExtractWS</i>
class is one such class.
<p><i>VConnectionUse</i> provides both a <b>submit</b> and an <b>execute</b>
member function to permit its subclasses and their users to pass arbitrary
expressions to Vision for execution.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Predicates

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int isConnected () const;
&nbsp;&nbsp;&nbsp;&nbsp; int isntConnected () const;

</pre><h5>Remarks:</h5></b>
<br>These member functions determine if the object is (is not) currently
connected to a Vision session.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Request Execution

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int submit (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VString&amp;&nbsp;&nbsp;&nbsp; iReply,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pRequest,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sReplyBufferInitialAllocation&nbsp;&nbsp; = 4096,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sReplyBufferAllocationIncrement = 4096,
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; int execute (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pRequest,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pDate = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pCurrency = 0
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>See the description of the <b>submit</b> and <b>execute</b> member
functions of <i>VConnection</i> for a full description of these member
functions.
<h4>

<hr WIDTH="100%"><a NAME="VDatum"></a></h4>

<h4>
class VDatum</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>&lt;none>
<p><b>Definition:</b>
<br>#include "VDatum.h"
<h4>
Overview</h4>
The <i>VDatum</i> class provides a general, variant data type. A VDatum
object can contain one of three kinds of value -- integers (C++ data type
int), real numbers (C++ data type double), and strings (C++ data type <i>VStringBase</i>).
Additionally, a <i>VDatum</i> object can contain an NA, indicating that
it is none of the above. Most of the operations associated with this class
deal with querying and updating the type and value contained in the <i>VDatum</i>
object.
<p>The <i>VDatum</i> class serves as the basis for returning arrays of
data from Vision. In particular, <i>VExtractWS</i> objects return the data
they retrieve from Vision in a <i>VDatumArray</i> (i.e., <i>VArray&lt;VDatum></i>).
<h4>
Supporting Types</h4>

<b><pre>enum VDatumKind {
&nbsp;&nbsp;&nbsp; VDatumKind_NA,
&nbsp;&nbsp;&nbsp; VDatumKind_Integer,
&nbsp;&nbsp;&nbsp; VDatumKind_Real,
&nbsp;&nbsp;&nbsp; VDatumKind_String
};

Operations

Category:
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VDatum (char const* pValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum (double iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum (int iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum ();

&nbsp;&nbsp;&nbsp;&nbsp; virtual ~VDatum ();

</pre><h5>Remarks:</h5></b>
<br><i>VDatum</i> class provides constructors for each of the variant types
supported for VDatum objects -- string, real, integer, and NA. When a VDatum
object is constructed using the <i>VDatum</i> (char const *) constructor,
the constructor makes a copy of the string data it is passed.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Access

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VDatumKind kind () const;

&nbsp;&nbsp;&nbsp;&nbsp; int isNA () const;
&nbsp;&nbsp;&nbsp;&nbsp; int isInteger () const;
&nbsp;&nbsp;&nbsp;&nbsp; int isReal () const;
&nbsp;&nbsp;&nbsp;&nbsp; int isString () const;

&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asInteger (int &amp;isValid) const;
&nbsp;&nbsp;&nbsp;&nbsp; double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asReal&nbsp;&nbsp;&nbsp; (int &amp;isValid) const;
&nbsp;&nbsp;&nbsp;&nbsp; char const* asString&nbsp; (int &amp;isValid) const;

&nbsp;&nbsp;&nbsp;&nbsp; operator char const* () const;
&nbsp;&nbsp;&nbsp;&nbsp; operator double () const;
&nbsp;&nbsp;&nbsp;&nbsp; operator int () const;

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category return the type and value of
a <i>VDatum</i>. The <b>kind</b> member function returns the current type
of the VDatum object in the form of a <i>VDatumKind</i> enumeration value.
The <b>isNA</b>, <b>isInteger</b>, <b>isReal</b> and <b>isString</b> member
functions test for specific <i>VDatum</i> data types.
<p>The <b>asInteger</b>, <b>asReal</b> and <b>asString</b> members return
the
<i>VDatum's</i> value if and only if it is of the requested type. These
functions convert reals to integers and integers to reals if possible;
however, they perform no other conversions. The <i>asString</i> member
function returns a pointer to the actual string contained in the <i>VDatum</i>
object. This pointer should be considered invalid as soon as the VDatum
object that supplied it is changed or destroyed. These routines all set
their <b>isValid</b> argument to a non-zero value if they were able to
supply the <i>VDatum's</i> value in the requested form and to zero if they
could not.
<p>The <b>char const*</b>, <b>double</b> and <b>int</b> conversion members
in this category are covers on the corresponding <b>as...</b> members that
ignore the value returned in the <b>isValid</b> argument. They should be
used only when you already know that the type of the <i>VDatum</i> object
will allow them to succeed.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Comparison

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (VDatum const &amp;iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (int iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (double iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (char const *pOther) const;

&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (VDatum const &amp;iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (int iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (double iOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (char const *pOther) const;

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category compare VDatum objects to each
other and to a set of standard C++ data types. Other than standard numeric
conversions and those that you allow based on your own conversion operators,
no conversions are automatically performed when making these comparisons.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Update

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; operator= (VDatum const&amp; iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; operator= (char const* pValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; operator= (double iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; operator= (int iValue);

&nbsp;&nbsp;&nbsp;&nbsp; void clear ();

&nbsp;&nbsp;&nbsp;&nbsp; int parse (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const* pString,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatumKind xExpectedKind = VDatumKind_NA
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category set the value of an existing
<i>VDatum</i>
object.
<p>The assignment operators in this category set the type and value of
the target <i>VDatum</i> object based on the value being assigned. If that
value is a string, the target <i>VDatum</i> object makes a copy of that
string.
<p>The <b>clear</b> member function sets the <i>VDatum</i> to NA.
<p>The <b>parse</b> member function sets the type and value of a <i>VDatum</i>
object to the result of parsing an input string. The value you pass to
the <i>xExpectedKind</i> argument tells this member function what kind
of data to expect and accept. When <i>VDatumKind_NA</i> is passed as the
value of xExpectedKind (the default), the <b>parse</b> member attempts
to convert its string argument to a number. The conversion will fail if
the string contains more than a syntactically valid number surrounded by
optional leading and trailing whitespace. If the conversion succeeds, the
target <i>VDatum</i> is set to that number. If the conversion fails and
the string contains Vision standard NA representation, the target <i>VDatum</i>
is set to NA. If neither a number nor a string is found, the target will
be set to a copy of the string argument with leading whitespace removed.
Passing other values from the <i>VDatumKind</i> enumeration to the xExpectedKind
argument restricts the set of conversions considered. Passing either <i>VDatumKind_Integer</i>
or
<i>VDatumKind_Real</i> restricts this member to the requested numeric
conversion. If that conversion fails, the target <i>VDatum</i> is set to
NA. Finally, passing <i>VDatumKind_String</i> suppresses all numeric and
NA conversions, setting the <i>VDatum</i> to a copy of this member's string
argument with leading whitespace removed.
<h4>

<hr WIDTH="100%"><a NAME="VExtractWS"></a></h4>

<h4>
class VExtractWS</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>VConnectionUse
<p><b>Subclasses:</b>
<br>&lt;none>
<p><b>Definition:</b>
<br>#include "VExtractWS.h"
<h4>
Supporting Types</h4>

<b><pre>enum VExtractOrientation {
&nbsp;&nbsp;&nbsp; VExtractOrientation_Unknown,
&nbsp;&nbsp;&nbsp; VExtractOrientation_EI,
&nbsp;&nbsp;&nbsp; VExtractOrientation_ET,
&nbsp;&nbsp;&nbsp; VExtractOrientation_IE,
&nbsp;&nbsp;&nbsp; VExtractOrientation_IT,
&nbsp;&nbsp;&nbsp; VExtractOrientation_TE,
&nbsp;&nbsp;&nbsp; VExtractOrientation_TI
};</pre></b>

<h4>
Overview</h4>
The <i>VExtractWS</i> class provides array structured access to Vision
data. It does so using the <i><a href="tkInterface.htm#extract">Interface
ExtractWS</a></i> Vision class. You can create and use as many <i>VExtractWS</i>
objects as you need. When you create a new <i>VExtractWS</i>, you generally
specify the connection object it will use to talk to Vision. The following
sample, which assumes that you have already created a VConnection object
named
<b>myConnection</b>, illustrates:
<b><pre>&nbsp;&nbsp;&nbsp; VExtractWS&nbsp; myExtractWS (&amp;myConnection);</pre></b>
Each <i>VExtractWS</i> object you create creates a corresponding <i>Interface
ExtractWS</i> Vision object with which it interacts. To use a <i>VExtractWS</i>
object, you use its <b>set...</b>, <b>add...</b>, and
<b>clear...</b> operations
to select the data you want. For example:
<b><pre>&nbsp;&nbsp;&nbsp; myExtractWS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setOrientationToEI ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .setEntityTypeTo ("Security")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("GM")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("IBM")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("HWP")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addEntity ("XON")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("name"&nbsp;&nbsp;&nbsp; , VDatumKind_String)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("price"&nbsp;&nbsp; , VDatumKind_Real)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .addItem ("price@95", VDatumKind_Real)
&nbsp;&nbsp;&nbsp; ;</pre></b>
With the extract workspace parameters set, you use the <b>run</b> operation
to request your data. The following example creates an empty two dimensional
array which it fills with the data specified by the extract workspace:
<b><pre>&nbsp;&nbsp;&nbsp; VDatumArray myDataArray (2);
&nbsp;&nbsp;&nbsp; if (!myExtractWS.run (myDataArray))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reportError ("Run Failed\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit (1);
&nbsp;&nbsp;&nbsp; }</pre></b>
The <i>VDatumArray</i> is resized and reshaped as needed to hold the result
of your query. The following code illustrates how you can display the data
you retrieved:
<b><pre>&nbsp;&nbsp;&nbsp; size_t rowCount = myDataArray.elementCount(0);
&nbsp;&nbsp;&nbsp; size_t colCount = myDataArray.elementCount(1);
&nbsp;&nbsp;&nbsp; for (unsigned int row = 0; row &lt; rowCount; row++)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (unsigned int col = 0; col &lt; colCount; col++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatum&amp; iElement = myDataArray.element (row, col);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (iElement.kind ())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_NA:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is NA\n", row, col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_Integer:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The Integer %d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (int)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_Real:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The Real Number %g\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (double)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case VDatumKind_String:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Is The String &lt;%s>\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col, (char const*)iElement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Row %u, Col %u Has An Unrecognized Type\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }</pre></b>

<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS (VExtractWS const&amp; iOther);
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS (VConnection* pConnection);

&nbsp;&nbsp;&nbsp;&nbsp; virtual ~VExtractWS ();

</pre><h5>Remarks:</h5></b>
<br>These routines create and destroy <i>VExtractWS</i> objects. Two forms
of constructor are supplied -- a copy constructor and a
<i>VConnection</i>
initialized constructor. The <i>VExtractWS</i>(<i>VConnection*</i>) constructor
is the one you are most likely to use; the copy constructor exists to ensure
that C++ knows how to copy the complex internal structure of an extract
workspace correctly. In particular, in addition to copying the source workspace
settings and connection data to the new workspace, the new workspace is
given an opportunity to create a remote object for its own use. From an
application perspective, you can use <i>VExtractWS's</i> copy constructor
to generate new extract workspace objects from a prototype workspace.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Assignment

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; operator= (VExtractWS const&amp; iOther);

</pre><h5>Remarks:</h5></b>
<br>The assignment operator copies the settings from one extract workspace
to another. The destination workspace remains attached to the same Vision
connection and <i>Vision Interface ExtractWS</i> object as it had initially.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Parameter Setting

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setCurrencyTo (char const *pName);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToEI ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToET ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToIE ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToIT ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToTE ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationToTI ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setOrientationTo(VExtractOrientation xOrientation);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setColumnLabelsOn ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setColumnLabelsOff ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setRowLabelsOn ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setRowLabelsOff ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setScalarLabelOn ();
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setScalarLabelOff ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setDelimiterTo (char const *pDelimiter);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setEntityTypeTo (char const *pString);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setEntityTo (char const *pString);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; addEntity (char const *pString);
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; clearEntityList ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setEntityListTo (char const *pString);
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setEntityListExpressionTo (char const *pString);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setItemTo (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *pString, VDatumKind xKind = VDatumKind_NA
&nbsp;&nbsp;&nbsp;&nbsp; );

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; addItem (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *pString, VDatumKind xKind = VDatumKind_NA
&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; clearItemList ();

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; setDateTo (char const *pString);

&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; addDate (char const *pString);
&nbsp;&nbsp;&nbsp;&nbsp; VExtractWS&amp; clearDateList ();

</pre><h5>Remarks:</h5></b>
<br>The routines in this category modify the data retrieval specification
parameters associated with an extract workspace. Because the member functions
in this category correspond to the operations described in the documentation
of the <i>Interface ExtractWS</i> Vision class, their descriptions are
not repeated here. There are, however, two differences and enhancements
that are unique to these member functions -- the single Vision mechanism
for specifying entity lists is divided into three member function groups
and the format for specifying items includes an optional result data type.
<p>The <i>Interface ExtractWS</i> class in Vision provides a single method
to set an entity list. That method accepts a single argument that can be
a list of entity names, a string containing a comma separated list of entity
names, or a block specifying the Vision expression to run to generate a
list of entities. The <i>VExtractWS</i> class implements these cases as
four member functions -- <b>addEntity</b>,
<b>clearEntityList</b>, <b>setEntityListTo</b>
and <b>setEntityListExpressionTo</b>.
<b>addEntity</b> and <b>clearEntityList</b>
build the entity list as a list of strings. <b>setEntityListTo</b> defines
the entity list as a single string containing a comma separated list of
entity names. Finally, <b>setEntityListExpressionTo</b> accepts a string
which it interprets as a Vision expression used to generate a list of entities.
<p>The <i>VExtractWS</i> class also provides result value conversion types.
When you specify an item -- either as the single item for time by entity
and entity by time data arrays or as an item in an item list for all other
array orientations -- you have the option of specifying the result data
type of the item. If you do not specify a type, the Vision C++ interface
kit will attempt to convert the data for that item into a number and to
recognize Vision NA values. Data not recognized as either will be returned
as a string. That is the effect of the default <i>VDatumKind_NA</i> value
for the optional <b>xKind</b> argument to the <b>setItemTo</b> and <b>addItem</b>
member functions. By specifying a different value for that argument, you
can alter this behavior. In particular, by specifying <b>VDatumKind_Integer</b>,
you are requesting that the item's data be returned as an integer or, if
it cannot be converted to an integer, as an NA. Similarly, specifying
<b>VDatumKind_Real</b>
as an item's data type requests that its data be returned as a double or
an NA. You can also turn off all conversion by specifying <b>VDatumKind_String</b>.
In this case, the item's data is always returned as a string. By default,
all row, column, and scalar label data is treated as string data.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Execution

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int run (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDatumArray&amp; rDataArray, unsigned int fReset = VFalse
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>This member function retrieves an array of data based on the current
settings in the extract workspace. If this routine succeeds, it returns
a non-zero value after it reshapes and fills 'rDataArray' with the data
you requested. If this routine fails, it returns zero. If this routine
fails, it may or may not have made changes to the content of <b>rDataArray</b>
depending on when in its processing it detected its error.
<p>By default, only the data access control parameters that have changed
are sent to Vision. The <b>fReset</b> optional argument to this member
function can be passed a non-zero value to cause all data access control
settings to be re-sent as part of the execution request.
<p>
<hr WIDTH="100%"><a NAME="VSockets"></a>
<h4>
class VSockets</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>&lt;none>
<p><b>Definition:</b>
<br>#include "VSockets.h"
<h4>
Overview</h4>
The <i>VSockets</i> class hides a number of operating system dependencies
associated with the use of sockets. Your application needs to create exactly
one instance of this class when it starts. It must keep that instance alive
and valid until it terminates. One way to do that is to create a local
variable of type VSockets in your main program:
<b><pre>&nbsp;&nbsp;&nbsp; int main (int argc, char* argv[])
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VSockets SocketSubsystem (VTrue);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp; }</pre></b>
You can use your favorite technique. Because your single <i>VSockets</i>
instance must be passed to the constructor for <i>VConnection</i> objects:
<b><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VConnection myConnection (SocketSubsystem);</pre></b>
and must be kept alive as long as any <i>VConnection</i> object is alive,
you must have access to it whenever you create an instance of class VConnection
and you must insure that your <i>VSockets</i> object is not destroyed as
long as any <i>VConnection</i> object needs it. The <i>VSockets</i> constructor
accepts a single argument which, when passed a non-zero value (VTrue will
do in this regard), causes the constructor to make whatever initialization
calls are required to make subsequent socket calls work in your application.
This is an issue only in environments that use the 'winsock' implementation
of sockets (e.g.., Microsoft Windows/NT, Microsoft Windows/95). If you
have made those initialization calls yourself or are using other libraries
that have already made those initialization calls, you may or may not need
to pass <i>VFalse</i> to the <i>VSockets</i> constructor.
<p>If you choose to do so, you may call the other member functions in this
class to perform the operations they provide; however, most of these operations
are intended for the use of the <i>VConnection</i> class.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VSockets (int fInitializationRequired);

&nbsp;&nbsp;&nbsp;&nbsp; ~VSockets ();

</pre><h5>Remarks:</h5></b>
<br>As noted in the overview of the <i>VSockets</i> class, the <i>VSockets</i>
constructor can make whatever initialization calls are required to allow
you to use sockets from your application. It will make those calls if it
is passed a non-zero argument value. If the <i>VSockets</i> constructor
makes the application initialization call, the <i>VSockets</i> destructor
will also make whatever matching application termination calls are required.
If you pass a zero to this constructor, you are responsible for making
these calls yourself.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Predicates

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int initialized ();

</pre><h5>Remarks:</h5></b>
<br>The <b>initialized</b> member returns a non-zero value if this
<i>VSockets</i>
instance had responsibility for making the application initialization calls
(see the remarks associated with the VSockets constructor and the class
overview) AND those calls succeeded. If either or both of these conditions
are true, this routine returns a non-zero value, otherwise, it returns
zero.
<b><pre>&nbsp;&nbsp; Category:
&nbsp;&nbsp;&nbsp;&nbsp; Remote Execution

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int rexec (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xDataSocket,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xControlSocket,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pErrorMessageBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sErrorMessageBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pHostName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pUserName,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pPassword,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *&nbsp;&nbsp;&nbsp; pCommand
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>This member function provides the client side interface to the remote
execution service. This member function uses the remote execution service
to run the specified command on the specified host for the specified user.
That host name can be specified symbolically (e.g., myHost) or in dotted
quad notation (e.g., 192.0.1.2). If the command can be run, this member
sets the values of xDataSocket and xControlSocket to the socket handles
connected to the standard input, output, and error of the remote process
and returns a non-zero value. The details of how these sockets are created
and used are described in the UNIX man page documentation for the remote
execution daemon (rexecd) and are not repeated here. If the command cannot
be run, usually because of a login or command string problem, this routine
returns a description of the error in the error message buffer and returns
zero. That description is usually obtained from the remote execution server.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Client Creation

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; SOCKET connect (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char const *pHostName, unsigned short xHostPort
&nbsp;&nbsp;&nbsp;&nbsp; );

</pre><h5>Remarks:</h5></b>
<br>This member function connects to a service listening for connections
at the specified port on the specified host. The host name can be specified
symbolically (e.g., myHost) or in dotted quad notation (e.g., 192.0.1.2).
If this routine fails, it returns INVALID_SOCKET; if it succeeds, it returns
a socket handle. The socket handle returned by this member function can
be used to send and receive data subject to the rules defined by the contacted
service.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Service Creation

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; SOCKET serve (u_short&amp; xPort, int sBacklog = 1);

</pre><h5>Remarks:</h5></b>
<br>This member function creates a service listening for connection requests
at port <b>xPort</b>. If this routine succeeds it returns a handle for
the listener socket; if it fails it returns INVALID_SOCKET. The socket
handle returned by this member function can be passed to the <b>accept</b>
function to accept new connections to this service.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Socket Query

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int socketName (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET xSocket, unsigned char iHost[4], unsigned short &amp;xPort
&nbsp;&nbsp;&nbsp;&nbsp; ) const;
&nbsp;&nbsp;&nbsp;&nbsp; int peerName (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCKET xSocket, unsigned char iHost[4], unsigned short &amp;xPort
&nbsp;&nbsp;&nbsp;&nbsp; ) const;

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category return the Internet octet style
host address and port of the local (socketName) and remote (peerName) end
points of the socket whose handle is <b>xSocket</b>. These routines return
a non-zero value when they succeed and zero when they fail.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Socket I/O

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int send (SOCKET xSocket, char const *pData, size_t sData);
&nbsp;&nbsp;&nbsp;&nbsp; int recv (SOCKET xSocket, char *pBuffer, size_t sBuffer);

</pre><h5>Remarks:</h5></b>
<br>These member functions send and receive data on a socket. They return
the number of bytes actually transferred or the constant SOCKET_ERROR if
they failed.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Socket Shutdown

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int endReception&nbsp;&nbsp;&nbsp; (SOCKET xSocket);
&nbsp;&nbsp;&nbsp;&nbsp; int endTransmission (SOCKET xSocket);

&nbsp;&nbsp;&nbsp;&nbsp; int close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SOCKET xSocket);

</pre><h5>Remarks:</h5></b>
<br>These member functions terminate various forms of communication on
a socket. The <b>endReception</b> member ends your ability to read data
from a socket and your peer's ability to send data to you using that socket.
The <b>endTransmission</b> member ends your ability to write data to a
socket and your peer's ability to read more data from you. In the case
of <b>endReception</b>, when your peer attempts to send you data, it will
get an error. In the case of
<b>endTransmission</b>, once your peer exhausts
what you sent prior to calling <b>endTransmission</b>., it will receive
an end of file. The
<b>close</b> function immediately ends all communication
on a socket.
<p>
<hr WIDTH="100%"><a NAME="VStringBase"></a>
<h4>
class VStringBase</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>&lt;none>
<p><b>Subclasses:</b>
<br>VString
<p><b>Definition:</b>
<br>#include "VString.h"
<h4>
Overview</h4>
The <i>VStringBase</i> class provides the core functionality for variable
length, null-terminated character strings. It is the base class for the
<i>VString</i>
class and provides most of the functionality of that class. It is distinct
from VString so that it can be used to implement the string member of the
<i>VDatum</i>
union. Because C++ requires that the types used to define the variants
of a union cannot have constructors or assignment operators,
<i>VStringBase</i>
is implemented without any. If you change the <i>VStringBase</i> class,
you must NEVER give it a constructor or an implementation for operator=;
if you do, the implementation of class <i>VDatum</i> will fail to compile.
<p>Note that because the <i>VStringBase</i> class defines the <b>char const*</b>
conversion operator, it can be used almost anywhere a conventional null-terminated
C or C++ string can be used.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Globals

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; static char const* const WhiteSpace;

</pre><h5>Remarks:</h5></b>
<br>This constant character string contains the characters classified as
white space by the Vision C++ interface kit routines that parse character
strings.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Initialization
</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (VStringBase const&amp; iString);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (char const* pString);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (char const* pString, size_t sString);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (char iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (double iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (int iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void initializeTo (unsigned int iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void initialize&nbsp;&nbsp; ();

</pre><h5>Remarks:</h5></b>
<br>The member functions in this category initialize a new
<i>VStringBase</i>
object. They are designed to be called from either a constructor of a <i>VStringBase</i>
derived class or by a routine that behaves like a constructor (i.e., the
<i>VDatum</i>
routines that change the type of a <i>VDatum</i> object to a string). These
routines should not be called by your application except to initialize
an un-initialized
<i>VStringBase</i> object. In particular, these routines
must not be used to change the content of an initialized
<i>VString</i>
or <i>VStringBase</i> object. If that is your intent, use one of the <b>setTo</b>
member functions or an assignment operator in a derived class.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; void destroy ();

</pre><h5>Remarks:</h5></b>
<br>This member function is used in lieu of a destructor. It is designed
to be called from the destructor of a <i>VStringBase</i> derived class
or by a routine that behaves like a destructor (i.e., the
<i>VDatum</i>
routines that change the type of a string <i>VDatum</i> object to some
other type or that destroy a <i>VDatum</i> object that contains a string).
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Buffer Sizing

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int guarantee (size_t sBuffer);

</pre><h5>Remarks:</h5></b>
<br>This member function ensures that the total size of the internal buffer
used to hold the content of the <i>VStringBase</i> object is at least <b>sBuffer</b>
bytes in length. This routine can be called by your application to preallocate
working space so that a series of updates to the same <i>VStringBase</i>
derived object can run more efficiently.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Comparison

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; int operator&lt;&nbsp; (char const* pOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator&lt;= (char const* pOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator== (char const* pOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator!= (char const* pOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator>= (char const* pOther) const;
&nbsp;&nbsp;&nbsp;&nbsp; int operator>&nbsp; (char const* pOther) const;

</pre><h5>Remarks:</h5></b>
<br>These member functions compare the content of a <i>VStringBase</i>
object to another string. Because <i>VStringBase</i> objects are converted
to type <b>char const*</b> if necessary, these routines are also used to
compare <i>VStringBase</i> derived objects to each other.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Access

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; operator char const* () const;

</pre><h5>Remarks:</h5></b>
<br>This member function returns a pointer to the internal string contained
in the <i>VStringBase</i> object. Because this pointer is shared with the
<i>VStringBase</i>
object, it should be considered invalid as soon as the
<i>VStringBase</i>
object that supplied it is changed or destroyed.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Counts and Sizes

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; size_t strlen () const;

</pre><h5>Remarks:</h5></b>
<br>This member function returns the length of the string contained in
this <i>VStringBase</i> object. The value returned by this routine has
the same interpretation as the value returned by the standard <b>strlen</b>
function. The value returned from this routine is NOT the size of the internal
string buffer.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Update

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; void clear ();

&nbsp;&nbsp;&nbsp;&nbsp; void setTo (VStringBase const&amp; iString);
&nbsp;&nbsp;&nbsp;&nbsp; void setTo (char const* pString);
&nbsp;&nbsp;&nbsp;&nbsp; void setTo (char iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void setTo (double iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void setTo (int iValue);
&nbsp;&nbsp;&nbsp;&nbsp; void setTo (unsigned int iValue);

&nbsp;&nbsp;&nbsp;&nbsp; void setTo (char const* pString, size_t sString);

&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (VDatum const&amp; iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (char const* pString);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (char iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (double iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (int iValue);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; operator&lt;&lt; (unsigned int iValue);

&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; append&nbsp;&nbsp;&nbsp;&nbsp; (char const* pString);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; quote&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (char const* pString);

&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; printf&nbsp;&nbsp;&nbsp;&nbsp; (char const* pFormat, ...);
&nbsp;&nbsp;&nbsp;&nbsp; VStringBase&amp; vprintf&nbsp;&nbsp;&nbsp; (char const* pFormat, va_list ap);

&nbsp;&nbsp;&nbsp;&nbsp; void setBuffer (char* pBuffer);
&nbsp;&nbsp;&nbsp;&nbsp; void setBuffer (char* pBuffer, size_t sBuffer);

</pre><h5>Remarks:</h5></b>
<br>These member functions provide various mechanisms for changing the
content of a <i>VStringBase</i> derived object.
<p>The clear member function sets the content of a <i>VStringBase</i> object
to the empty string.
<p>The <b>setTo</b> member functions set the content of a <i>VStringBase</i>
object to another string or to the standard string representation of a
number.
<p>The <b>operator&lt;&lt;</b> and <b>append</b> member functions append
a string or the standard representation of a number as a string to a <i>VStringBase</i>
object. The <b>quote</b> member function appends a quoted representation
of a string to a <i>VStringBase</i> object.
<p>The <b>printf</b> and <b>vprintf</b> member functions append a string
formatted using <b>printf</b> style conventions to a <i>VStringBase</i>
object.
<p>The <b>setBuffer</b> member functions replace the internal buffer of
a
<i>VStringBase</i> object with a buffer you supply. That buffer must
be allocated using either <b>malloc</b> or <b>realloc</b>. Once you pass
its address to one of these member functions, you relinquish control over
its lifetime and allocation to the <i>VStringBase</i> object. In particular,
you must not free or reallocate it and should not retain a pointer to it.
These member functions are provided primarily for the use of the <i>VConnection</i>
submit member function which manages a potentially large buffer which it
ultimately will return as the content of a VString object.
<p>
<hr WIDTH="100%"><a NAME="VString"></a>
<h4>
class VString</h4>

<h4>
Synopsis</h4>
<b>Superclasses:</b>
<br>VStringBase
<p><b>Subclasses:</b>
<br>none
<p><b>Definition:</b>
<br>#include "VString.h"
<h4>
Overview</h4>
The <i>VString</i> class implements variable length, null-terminated strings.
It inherits most of its functionality from <i>VStringBase</i>, adding the
constructors and assignment operators that make it useful as a standard
C++ class and that cannot be added to <i>VStringBase</i>.
<h4>
Operations</h4>

<b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Construction/Destruction

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VString (VString const&amp; iString)
&nbsp;&nbsp;&nbsp;&nbsp; VString (char const* pString, size_t sString)
&nbsp;&nbsp;&nbsp;&nbsp; VString (char const* pString)
&nbsp;&nbsp;&nbsp;&nbsp; VString ()

&nbsp;&nbsp;&nbsp;&nbsp; virtual ~VString ();

</pre><h5>Remarks:</h5></b>
<br>These routines provide default and copy constructors for
<i>VString</i>
as well as two forms of C++ string based construction. As is the case for
all <i>VStringBase</i> and <i>VString</i> routines, a private copy is made
of the string data used to initialize a <i>VString</i> object.
<h5><hr WIDTH="50%"></h5><b><h5>Category:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; Assignment

</pre><h5>Members:</h5><pre>
&nbsp;&nbsp;&nbsp;&nbsp; VString&amp; operator= (VString const&amp; iString)
&nbsp;&nbsp;&nbsp;&nbsp; VString&amp; operator= (char const* pString)
&nbsp;&nbsp;&nbsp;&nbsp; VString&amp; operator= (double iValue)
&nbsp;&nbsp;&nbsp;&nbsp; VString&amp; operator= (int iValue)
&nbsp;&nbsp;&nbsp;&nbsp; VString&amp; operator= (unsigned int iValue)

</pre><h5>Remarks:</h5></b>
<br>These member functions provide a number of <i>VString</i> assignment
operators including assignment operators that convert numbers to strings.&nbsp;
<hr>
<table BORDER=0 WIDTH="100%" >
<tr>
<td align=left><font size=-1>Copyright &copy; 2000 Innovative Systems Techniques, Inc.</font>
<td align=right><font size=-1>Updated December 15, 2000</font>
</tr>
</table>

</body>
</html>
